"""
BOJ 11726 2xn 타일링

사용 가능한 블럭은 넓이 1과 2의 타일 한개 씩
타일을 채우는 경우의 수 = 가중치가 1인 값과 2인 값을 더해서 해당 넓이를 만드는 경우의 수와 같음
ex 5를 만드는 경우의 수 - > 각 블록을 넓이로 표현했을 때 11111 1112 1121 1211 2111 122 212 122      8개
ex 4를 만드는 경우의 수 - > 각 블록을 넓이로 표현했을 때 1111 112 121 211 22                        5개
ex 3을 만드는 경우의 수 - > 각 블록을 넓이로 표현했을 때 111 12 21                                  3개
ex 2를 만드는 경우의 수 - > 각 블록을 넓이로 표현했을 때 11 2                                       2개
ex 1을 만드는 경우의 수 - > 각 블록을 넓이로 표현했을 때 1                                          1개

다 그려놓고 보면 경우의 수는 피보나치 수열로 증가한다...
영원히 이렇게 증가한다고 증명할 수 있을까?

각 넓이 n을 수열로 생각하고
넓이 수열의 항을 다시 i항까지 있는 수열이라고 생각할 때
n > 2에서
i == 1은 2를 0개 사용하는 경우, 즉 1만 사용해서 n을 만드는 경우다. 언제나 방법은 유일하다. -> 1
i == 2는 2를 1개 사용하는 경우, n-2만큼 연속된 1 사이에 2를 배치할 수 있는 횟수다. -> 1의 개수는 n - ( 2 * (i-1) ) -> 배치 가능한 경우는 개수 + 1
3항은 2를 2개 사용하는 경우, 1의 개수는 역시 n - ( 2 * (i - 1) ), 배치 가능한 경우의 수는 역시 1의 개수 + 1
.
.
n - ( 2 * (i - 1) ) >= 0 일때 까지 i 1씩 증가시키며 반복


이를 다시 정리하면 i = 1부터 k까지

    n - ( 2 * (1 - 1) ) + 1
+   n - ( 2 * (2 - 1) ) + 1
+   n - ( 2 * (3 - 1) ) + 1
.
.
.
+   n - ( 2 * (k - 1) ) + 1
// 초항을 제외하고
= n * k - ( k*(k-1) ) + k
= k( n - (k-1) + 1)
= k( n - k + 2)


k 는 1씩 증가시키면서 찾아야 하는가...
이럼 dp가 아닌데?
"""

import sys

input = sys.stdin.readline


def get_input():
    return int(input())


def solution(params):
    pass


if __name__ == "__main__":
    print(solution(get_input()))
